## 排序

### 1. 排序算法

排序算法有很多，但是最经典和常用的，有：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。

同样是 $O(n^2)$ 的算法，为何实际更多使用插入排序而不是冒泡排序？

**1.1. 排序算法的评估**

1. 考虑最好最坏平均情况的复杂度
2. 时间复杂度的系数、常数和低阶项都要考虑
3. 比较次数和交换次数要考虑
4. 排序算法的内存消耗（原地排序：$O(1)$ 的空间复杂度
5. 稳定性：相同的值在排序完后其前后顺序不改变

问：10 万条订单数据，希望按照金额从小到大，金额相同按时间先后排序。

答：先按时间先后对订单排序，然后用稳定排序对金额排序。

### 2. 冒泡、插入、选择排序

**2.1. 冒泡排序**

![冒泡排序](assets/冒泡排序.jpg)

一次冒泡就会有一个元素被放到正确的位置。如果有一次冒泡没有进行元素的交换，就证明数组已经排序完成了，可以提前结束循环。

**有序度和逆序度**：如果前面的数大于后面的数，就是逆序度，前面的数小于后面的数，就是有序度。满有序度为 $n*(n-1)/2$。

**2.2. 插入排序**

![](assets/插入排序.jpg)

插入排序的优化：[希尔排序]([https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F](https://zh.wikipedia.org/wiki/希尔排序))

**2.3. 选择排序**

选择排序把数组分为两个区间，每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
![](assets/选择排序.jpg)


![](assets/插入冒泡选择对比.jpg)

### 3. 归并和快排

这两种排序的时间复杂度都为 $O(n\log n)$，适合大规模的数据。

**3.1. 归并排序**

归并使用分治思想，常利用递归来解决。可以利用分治思想，解决非排序的问题：寻找无序数组中的第 K 大元素

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

[703. 数据流中的第K大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

归并排序的思想，把要排序的数组分成两段，一点一点分到无法再分，再把每一小段排序好的接起来。

**3.2. 快速排序**

思想，选择要排序的数组中一个数据作为分区点，大于这个数据的放一边，小于这个数据的放另一边。

|              |  原地  | 稳定 |     最好     |     最坏     |     平均     |
| :----------: | :----: | :--: | :----------: | :----------: | :----------: |
| **冒泡排序** |   √    |  √   |    $O(n)$    |   $O(n^2)$   |   $O(n^2)$   |
| **插入排序** |   √    |  √   |    $O(n)$    |   $O(n^2)$   |   $O(n^2)$   |
| **选择排序** |   √    |  ×   |   $O(n^2)$   |   $O(n^2)$   |   $O(n^2)$   |
| **归并排序** | $O(n)$ |  √   | $O(n\log n)$ | $O(n\log n)$ | $O(n\log n)$ |
| **快速排序** |   √    |  ×   | $O(n\log n)$ |   $O(n^2)$   | $O(n\log n)$ |

### 4. 线性排序

**4.1. 桶排序**

把要排序的数据均匀分到 m 个桶，在每个桶内使用快速排序。当桶的个数接近数据个数 n 时时间复杂度就会接近 $O(n)$。

桶排序有个弱点：它对要排序的数据要求比较苛刻，要求分到每个桶的数据能够平均。它适合于外部排序，即要排序的数据很大，不能够一次性装进内存里的。

**4.2. 计数排序**

计数排序像是桶排序的特殊情况。利用一个计数数组，每个位置对应一个桶，下标代表放在该桶的分数（相同分数的放在同一个桶），下标对应的位置存着这个分数的数据量。对其进行顺序求和。在扫描整个数据的时候，每个数据把它放在计数数组中该数据对应下标上的数字的位置就行。

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

**4.3. 基数排序**

### 5. 排序优化

**5.1. 优化快速排序**

快速排序如果分区点选取不合理，就会出现时间复杂度退化为 $O(n^2)$ 的情况。因此要合理的安排分区点。

**（1）三数取中法**

从头尾和中间分别取一个数，把这三个数的中间值作为分区点。如果数组较大，还可以使用「五数取中」和「十数取中」。

**（2）随机法**

随机法，每次从要排序的区间中随机选择一个元素，这样可以降低严重退化的概率。

**5.2. 代码的对比**

代码的时间复杂度并不等于实际运行的时间。也就是说，时间复杂度高的代码，有可能时间花费更加少。时间复杂度只是代表一个增长趋势。